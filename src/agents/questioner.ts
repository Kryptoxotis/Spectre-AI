/**n * Spectre AI Assistant - Questioner Agentn * Handles intelligent questioning and context gatheringn */nnimport { v4 as uuidv4 } from 'uuid';nimport { IAgent, AgentType, AgentContext, AgentResult, Project, Question, QuestionAnswer, QuestionType, ProjectType } from '../utils/types';nimport { spectreLogger } from '../core/logger';nimport { config } from '../core/config';nn/**n * Questioner Agent Implementationn */nexport const questioner: IAgent = {n  type: 'questioner',n  name: 'Questioner',n  description: 'Intelligent questioning agent that gathers context and requirements',n  capabilities: [n    'context_analysis',n    'question_generation',n    'answer_validation',n    'pattern_learning',n    'session_management'n  ],n  isActive: true,n  version: '1.0.0',nn  /**n   * Execute the questioner agentn   */n  async execute(context: AgentContext): Promise<AgentResult> {n    const startTime = Date.now();n    const { projectId, project } = context;nn    try {n      spectreLogger.success('questioner', 'execution_started', undefined, projectId,n        'Questioner agent execution started', 'analyzing_project_context',n        { projectType: project.type, projectName: project.name });nn      // Generate questions based on project typen      const questions = await this.generateQuestions(project);nn      // Store questions in project contextn      project.answers = [];n      project.status = 'questioning';nn      spectreLogger.success('questioner', 'questions_generated', undefined, projectId,n        `Generated ${questions.length} questions for ${project.type} project`, 'questions_ready',n        { questionCount: questions.length, projectType: project.type });nn      const duration = Date.now() - startTime;nn      return {n        success: true,n        data: {n          questions,n          projectStatus: project.status,n          estimatedDuration: this.estimateQuestioningDuration(questions.length),n        },n        metadata: {n          questionCount: questions.length,n          duration,n          projectType: project.type,n        },n        nextStep: 'planner',n      };nn    } catch (error) {n      const duration = Date.now() - startTime;n      spectreLogger.failure('questioner', 'execution_failed', n        error instanceof Error ? error.message : String(error), projectId,n        'Questioner agent execution failed', 'error_handled',n        { duration, projectType: project.type });nn      return {n        success: false,n        error: error instanceof Error ? error.message : String(error),n        metadata: { duration, projectType: project.type },n      };n    }n  },nn  /**n   * Check if this agent can handle the given stepn   */n  canHandle(step: any): boolean {n    return step.type === 'question' || step.agent === 'questioner';n  },nn  /**n   * Generate questions based on project typen   */n  private async generateQuestions(project: Project): Promise<Question[]> {n    const questions: Question[] = [];n    const baseQuestions = this.getBaseQuestions();n    const typeSpecificQuestions = this.getTypeSpecificQuestions(project.type);nn    // Add base questionsn    questions.push(...baseQuestions);nn    // Add type-specific questionsn    questions.push(...typeSpecificQuestions);nn    // Sort questions by ordern    questions.sort((a, b) => a.order - b.order);nn    return questions;n  },nn  /**n   * Get base questions for all project typesn   */n  private getBaseQuestions(): Question[] {n    return [n      {n        id: uuidv4(),n        text: 'What is the primary goal of this project?',n        type: 'text' as QuestionType,n        required: true,n        order: 1,n        validation: { minLength: 10, maxLength: 500 },n      },n      {n        id: uuidv4(),n        text: 'Who is the target audience?',n        type: 'text' as QuestionType,n        required: true,n        order: 2,n        validation: { minLength: 5, maxLength: 200 },n      },n      {n        id: uuidv4(),n        text: 'What is your timeline for completion?',n        type: 'select' as QuestionType,n        required: true,n        order: 3,n        options: ['1-2 weeks', '1 month', '2-3 months', '3+ months'],n      },n      {n        id: uuidv4(),n        text: 'What is your budget range?',n        type: 'select' as QuestionType,n        required: false,n        order: 4,n        options: ['$0-500', '$500-2000', '$2000-5000', '$5000+'],n      },n      {n        id: uuidv4(),n        text: 'Do you have any specific design preferences?',n        type: 'text' as QuestionType,n        required: false,n        order: 5,n        validation: { maxLength: 300 },n      },n    ];n  },nn  /**n   * Get type-specific questionsn   */n  private getTypeSpecificQuestions(projectType: ProjectType): Question[] {n    if (projectType === 'website') {n      return this.getWebsiteQuestions();n    } else {n      return this.getAutomationQuestions();n    }n  },nn  /**n   * Get questions specific to website projectsn   */n  private getWebsiteQuestions(): Question[] {n    return [n      {n        id: uuidv4(),n        text: 'What type of website do you need?',n        type: 'select' as QuestionType,n        required: true,n        order: 6,n        options: ['Portfolio', 'Business', 'E-commerce', 'Blog', 'Landing Page', 'Web App'],n      },n      {n        id: uuidv4(),n        text: 'Do you need user authentication?',n        type: 'boolean' as QuestionType,n        required: true,n        order: 7,n      },n      {n        id: uuidv4(),n        text: 'Do you need a content management system (CMS)?',n        type: 'boolean' as QuestionType,n        required: true,n        order: 8,n      },n      {n        id: uuidv4(),n        text: 'What features are most important?',n        type: 'multiselect' as QuestionType,n        required: false,n        order: 9,n        options: ['Contact Form', 'Blog', 'Gallery', 'Search', 'Analytics', 'SEO Optimization'],n      },n      {n        id: uuidv4(),n        text: 'Do you have existing content or assets?',n        type: 'text' as QuestionType,n        required: false,n        order: 10,n        validation: { maxLength: 200 },n      },n    ];n  },nn  /**n   * Get questions specific to automation projectsn   */n  private getAutomationQuestions(): Question[] {n    return [n      {n        id: uuidv4(),n        text: 'What type of automation do you need?',n        type: 'select' as QuestionType,n        required: true,n        order: 6,n        options: ['Data Processing', 'File Management', 'API Integration', 'Scheduling', 'Monitoring', 'Reporting'],n      },n      {n        id: uuidv4(),n        text: 'What systems need to be integrated?',n        type: 'multiselect' as QuestionType,n        required: true,n        order: 7,n        options: ['Email', 'CRM', 'Database', 'Cloud Storage', 'Social Media', 'Analytics'],n      },n      {n        id: uuidv4(),n        text: 'How often should the automation run?',n        type: 'select' as QuestionType,n        required: true,n        order: 8,n        options: ['Real-time', 'Hourly', 'Daily', 'Weekly', 'Monthly'],n      },n      {n        id: uuidv4(),n        text: 'Do you need error handling and notifications?',n        type: 'boolean' as QuestionType,n        required: true,n        order: 9,n      },n      {n        id: uuidv4(),n        text: 'What is the expected data volume?',n        type: 'select' as QuestionType,n        required: false,n        order: 10,n        options: ['Low (< 100 records)', 'Medium (100-1000 records)', 'High (1000+ records)'],n      },n    ];n  },nn  /**n   * Estimate how long questioning will taken   */n  private estimateQuestioningDuration(questionCount: number): number {n    // Base time per question (in minutes)n    const baseTimePerQuestion = 2;n    // Additional time for complex questionsn    const complexityMultiplier = 1.5;n    return Math.round(questionCount * baseTimePerQuestion * complexityMultiplier);n  },n};