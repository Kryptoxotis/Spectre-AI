/**n * Spectre AI Assistant - Planner Agentn * Creates detailed execution plans based on project requirementsn */nnimport { v4 as uuidv4 } from 'uuid';nimport { IAgent, AgentType, AgentContext, AgentResult, Project, ExecutionPlan, ExecutionStep, StepType, ProjectType } from '../utils/types';nimport { spectreLogger } from '../core/logger';nimport { config } from '../core/config';nn/**n * Planner Agent Implementationn */nexport const planner: IAgent = {n  type: 'planner',n  name: 'Planner',n  description: 'Strategic planning agent that creates detailed execution plans',n  capabilities: [n    'plan_generation',n    'dependency_analysis',n    'resource_estimation',n    'risk_assessment',n    'timeline_planning'n  ],n  isActive: true,n  version: '1.0.0',nn  /**n   * Execute the planner agentn   */n  async execute(context: AgentContext): Promise<AgentResult> {n    const startTime = Date.now();n    const { projectId, project } = context;nn    try {n      spectreLogger.success('planner', 'execution_started', undefined, projectId,n        'Planner agent execution started', 'analyzing_project_requirements',n        { projectType: project.type, projectName: project.name });nn      // Generate execution plann      const plan = await this.generateExecutionPlan(project);nn      // Update project statusn      project.plan = plan;n      project.status = 'planning';nn      spectreLogger.success('planner', 'plan_generated', undefined, projectId,n        `Generated execution plan with ${plan.steps.length} steps`, 'plan_ready_for_review',n        { stepCount: plan.steps.length, estimatedDuration: plan.estimatedDuration });nn      const duration = Date.now() - startTime;nn      return {n        success: true,n        data: {n          plan,n          projectStatus: project.status,n        },n        metadata: {n          stepCount: plan.steps.length,n          estimatedDuration: plan.estimatedDuration,n          complexity: plan.complexity,n          riskLevel: plan.riskLevel,n          duration,n        },n        nextStep: 'executor',n        requiresApproval: true,n      };nn    } catch (error) {n      const duration = Date.now() - startTime;n      spectreLogger.failure('planner', 'execution_failed', n        error instanceof Error ? error.message : String(error), projectId,n        'Planner agent execution failed', 'error_handled',n        { duration, projectType: project.type });nn      return {n        success: false,n        error: error instanceof Error ? error.message : String(error),n        metadata: { duration, projectType: project.type },n      };n    }n  },nn  /**n   * Check if this agent can handle the given stepn   */n  canHandle(step: any): boolean {n    return step.type === 'plan' || step.agent === 'planner';n  },nn  /**n   * Generate execution plan based on project requirementsn   */n  private async generateExecutionPlan(project: Project): Promise<ExecutionPlan> {n    const steps: ExecutionStep[] = [];n    const dependencies: string[] = [];nn    // Add common stepsn    steps.push(...this.getCommonSteps(project));nn    // Add type-specific stepsn    if (project.type === 'website') {n      steps.push(...this.getWebsiteSteps(project));n    } else {n      steps.push(...this.getAutomationSteps(project));n    }nn    // Add final stepsn    steps.push(...this.getFinalSteps(project));nn    // Calculate dependenciesn    this.calculateDependencies(steps);nn    // Calculate estimated durationn    const estimatedDuration = this.calculateEstimatedDuration(steps);nn    // Determine complexityn    const complexity = this.determineComplexity(steps);nn    // Assess risk leveln    const riskLevel = this.assessRiskLevel(steps, project);nn    const plan: ExecutionPlan = {n      id: uuidv4(),n      projectId: project.id,n      steps,n      estimatedDuration,n      complexity,n      dependencies,n      riskLevel,n      createdAt: new Date(),n      status: 'draft',n    };nn    return plan;n  },nn  /**n   * Get common steps for all project typesn   */n  private getCommonSteps(project: Project): ExecutionStep[] {n    const steps: ExecutionStep[] = [];n    let order = 1;nn    // Project setupn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Project Setup',n      description: 'Initialize project structure and configuration',n      type: 'plan' as StepType,n      agent: 'planner' as AgentType,n      status: 'pending',n      estimatedDuration: 30,n      dependencies: [],n      metadata: {n        action: 'setup_project',n        projectName: project.name,n        projectType: project.type,n      },n      retryCount: 0,n      maxRetries: 3,n    });nn    // Requirements analysisn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Requirements Analysis',n      description: 'Analyze project requirements and constraints',n      type: 'plan' as StepType,n      agent: 'planner' as AgentType,n      status: 'pending',n      estimatedDuration: 45,n      dependencies: [],n      metadata: {n        action: 'analyze_requirements',n        questionCount: project.answers.length,n      },n      retryCount: 0,n      maxRetries: 2,n    });nn    return steps;n  },nn  /**n   * Get steps specific to website projectsn   */n  private getWebsiteSteps(project: Project): ExecutionStep[] {n    const steps: ExecutionStep[] = [];n    let order = 3;nn    // Repository creationn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Create GitHub Repository',n      description: 'Create and configure GitHub repository for the project',n      type: 'repository_creation' as StepType,n      agent: 'executor' as AgentType,n      status: 'pending',n      estimatedDuration: 15,n      dependencies: [],n      metadata: {n        action: 'create_repository',n        repositoryName: this.generateRepositoryName(project.name),n      },n      retryCount: 0,n      maxRetries: 3,n    });nn    // CMS setupn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Setup Content Management System',n      description: 'Configure Notion or Supabase for content management',n      type: 'cms_setup' as StepType,n      agent: 'executor' as AgentType,n      status: 'pending',n      estimatedDuration: 60,n      dependencies: [],n      metadata: {n        action: 'setup_cms',n        cmsType: 'notion',n        fallback: 'supabase',n      },n      retryCount: 0,n      maxRetries: 2,n    });nn    // Code generationn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Generate Website Code',n      description: 'Generate frontend and backend code for the website',n      type: 'code_generation' as StepType,n      agent: 'executor' as AgentType,n      status: 'pending',n      estimatedDuration: 120,n      dependencies: [],n      metadata: {n        action: 'generate_website_code',n        technologies: ['React', 'TypeScript', 'Tailwind CSS'],n      },n      retryCount: 0,n      maxRetries: 2,n    });nn    // Deploymentn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Deploy to Vercel',n      description: 'Deploy the website to Vercel platform',n      type: 'deployment' as StepType,n      agent: 'executor' as AgentType,n      status: 'pending',n      estimatedDuration: 30,n      dependencies: [],n      metadata: {n        action: 'deploy_to_vercel',n        platform: 'vercel',n      },n      retryCount: 0,n      maxRetries: 3,n    });nn    return steps;n  },nn  /**n   * Get steps specific to automation projectsn   */n  private getAutomationSteps(project: Project): ExecutionStep[] {n    const steps: ExecutionStep[] = [];n    let order = 3;nn    // Workflow designn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Design Automation Workflow',n      description: 'Design the automation workflow using n8n',n      type: 'code_generation' as StepType,n      agent: 'executor' as AgentType,n      status: 'pending',n      estimatedDuration: 90,n      dependencies: [],n      metadata: {n        action: 'design_workflow',n        platform: 'n8n',n      },n      retryCount: 0,n      maxRetries: 2,n    });nn    // Integration setupn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Setup Integrations',n      description: 'Configure API integrations and connections',n      type: 'code_generation' as StepType,n      agent: 'executor' as AgentType,n      status: 'pending',n      estimatedDuration: 60,n      dependencies: [],n      metadata: {n        action: 'setup_integrations',n        integrations: ['email', 'database', 'api'],n      },n      retryCount: 0,n      maxRetries: 3,n    });nn    // Testingn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Test Automation',n      description: 'Test the automation workflow with sample data',n      type: 'validation' as StepType,n      agent: 'validator' as AgentType,n      status: 'pending',n      estimatedDuration: 45,n      dependencies: [],n      metadata: {n        action: 'test_automation',n        testType: 'integration_test',n      },n      retryCount: 0,n      maxRetries: 2,n    });nn    return steps;n  },nn  /**n   * Get final steps for all project typesn   */n  private getFinalSteps(project: Project): ExecutionStep[] {n    const steps: ExecutionStep[] = [];n    let order = 8;nn    // Code reviewn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Code Review',n      description: 'Review generated code for quality and security',n      type: 'review' as StepType,n      agent: 'reviewer' as AgentType,n      status: 'pending',n      estimatedDuration: 30,n      dependencies: [],n      metadata: {n        action: 'code_review',n        reviewType: 'quality_security',n      },n      retryCount: 0,n      maxRetries: 2,n    });nn    // Final validationn    steps.push({n      id: uuidv4(),n      order: order++,n      title: 'Final Validation',n      description: 'Validate project completion and functionality',n      type: 'validation' as StepType,n      agent: 'validator' as AgentType,n      status: 'pending',n      estimatedDuration: 45,n      dependencies: [],n      metadata: {n        action: 'final_validation',n        validationType: 'comprehensive',n      },n      retryCount: 0,n      maxRetries: 2,n    });nn    return steps;n  },nn  /**n   * Calculate dependencies between stepsn   */n  private calculateDependencies(steps: ExecutionStep[]): void {n    // Simple dependency calculation - can be enhancedn    for (let i = 1; i < steps.length; i++) {n      steps[i].dependencies.push(steps[i - 1].id);n    }n  },nn  /**n   * Calculate estimated duration for the entire plann   */n  private calculateEstimatedDuration(steps: ExecutionStep[]): number {n    return steps.reduce((total, step) => total + step.estimatedDuration, 0);n  },nn  /**n   * Determine project complexityn   */n  private determineComplexity(steps: ExecutionStep[]): 'simple' | 'medium' | 'complex' {n    const stepCount = steps.length;n    const totalDuration = this.calculateEstimatedDuration(steps);nn    if (stepCount <= 5 && totalDuration <= 120) return 'simple';n    if (stepCount <= 8 && totalDuration <= 240) return 'medium';n    return 'complex';n  },nn  /**n   * Assess risk leveln   */n  private assessRiskLevel(steps: ExecutionStep[], project: Project): 'low' | 'medium' | 'high' {n    const hasExternalIntegrations = steps.some(step => n      step.metadata?.action?.includes('integration') ||n      step.metadata?.action?.includes('deploy')n    );nn    const hasComplexSteps = steps.some(step => step.estimatedDuration > 60);nn    if (!hasExternalIntegrations && !hasComplexSteps) return 'low';n    if (hasExternalIntegrations && !hasComplexSteps) return 'medium';n    return 'high';n  },nn  /**n   * Generate repository name from project namen   */n  private generateRepositoryName(projectName: string): string {n    return projectName.toLowerCase().replace(/[^a-z0-9]/g, '-');n  },n};